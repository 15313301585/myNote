<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    //JS中的两种编程思想：同步、异步
    //JS是单线程的->做着当前的这个事情，没有完成之前，绝对不会做下一件事情
    //1.同步->上一件事情没有完成，继续处理上一件事件，只有上一件事情完成了，才会做下一件事情（js中大部分是同步编程的）
    //for循环就是同步编程的，只有循环结束后，才会继续执行下面的代码
//    while(1){
//
//    }
//    console.log("ok");//->永远都不会执行，因为上面的循环是死循环

    //2.异步->规划要做一件事件，但是不是立马去执行这件事情，需要等一定时间，这样的话，我们不会等着他执行，而是继续执行下面的操作，“只有当下面的事情都处理完成了，才会返回头处理之前的事情，如果下面的事情的并没有处理完成，不管之前的事情有没有到时间，都踏踏实实的等着”，
    //->在js中异步编程只有四种情况：定时器是异步编程、所有的事件绑定都是异步编程、Ajax读取数据的时候，我们一般都设置为异步编程、回调函数也是异步编程


    //->每一个浏览器对于定时器的等待时间都有一个最小值，谷歌：5~6ms  IE:10~13ms,如果我们的等待时间小于这个值，不起作用，还是需要等到最小时间才执行的；尤其是写0也不是立即执行；
//    var n=0;
//    window.setTimeout(function () {
//        n++;
//        console.log(n);//->1  第二次输出
//    },0);
//    console.log(n);//->0  第一次输出


//        var n=0;
//        window.setTimeout(function () {
//            n++;
//            console.log(n);//->1  第二次输出
//        },0);
//        console.log(n);//->0  第一次输出



    //我们定时器设置的时间不一定就是最后执行的时间，如果定时器之后还有其他的事情正在处理中，不管定时器的时间有没有到，都是不会执行定时器的
//    var n=0;
//    window.setTimeout(function () {
//        n++;
//        console.log(n);//不执行
//    },0);
//    console.log(n);//->0  输出一次0
//    while (1){ //死循环
//        n++;
//    }
//    console.log(n);//不执行


//    var n=0;
//    window.setTimeout(function () {
//        n+=2;
//        console.log(n); //7 第四次输出
//    },20);
//    window.setTimeout(function () {
//        n+=5;
//        console.log(n); //5 第三次输出
//    },5);
//    console.log(n);//0 第一次输出
//    for(var i=0;i<10000000;i++){
//
//    }
//    console.log(n); //0 第二次输出




    for(var i=0;i<oLis.length;i++){
        oLis[i].onclick=function () {
            change(i);
        }
    }


</script>
</body>
</html>